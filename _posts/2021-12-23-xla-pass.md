---
layout: post
title: XLA Pass功能分析
date: 2021-12-23
comments: true
categories: [ "TensorFlow", "XLA" ]
---

## 1. XLA Pass概述

<center>
    <img src="/images/posts/xla/pass_uml.svg" width="100%" alt="XLA Pass UML" title="XLA Pass 类UML图"/>
    <p>图 1. XLA Pass 类UML图</p>
</center>

分析`GpuCompiler::OptimizeHloModule`的调用过程，总结在GPU设备上XLA所使用的Pass类型及其之间的关系如图1所示。由图1可知，GPU上所使用的优化Pass基本是`HloModulePass`和`OpExpanderPass`的子类。去除四个用于保证HLO到LLVM IR之间转换正确性的Pass，在GPU上XLA使用的优化Pass多达75个。

HloPassInterface位于XLA HLO Pass继承关系的最顶层（即所有Pass类的公共基类），它主要定义了*Run*和*RunOnModuleGroup*两个纯虚函数，由其衍生出`HloPassPipeline`、`HloModulePass`和`HloModuleGroupPass`三个子类。XLA HLO Pass优化过程可由多个pipeline构成，每个pipeline即为`HloPassPipeline`的一个对象。GPU上的XLA Pass优化即被分为**spmd-partitioner**[^1]、**spmd-simplify**、**optimization**、**simplification**、**collective-optimizations**、**layout-assignment**、**post-layout-assignment**、**fusion**、**horizontal-fusion**、**post-fusion-optimization**以及**GPU-ir-emit-prepare**等11个pipeline。基本上所有的优化Pass均直接或间接继承自`HloModulePass`类。`OpExpanderPass`是`HloModulePass`的一个子类，由其再派生出十数个子类，主要用于各类算子的展开。`HloModuleGroupPass`类在XLA中基本没有被使用到。`HloPassFix`更类似一个修饰类，其模板参数会作为该类的父类，模板参数类被修饰后只会运行固定的迭代次数。

## 2. XLA重点Pass类功能分析

### 2.1 AlgebraicSimplifier

AlgebraicSimplifierl类在若干个优化pipeline中均有使用，它主要提了一些代数化简功能。
<center>
    <img src="/images/posts/xla/AlgebraicSimplifier.svg" width="100%" alt="AlgebraicSimplifier" title="AlgebraicSimplifier相关类UML图"/>
    <p>图 2. AlgebraicSimplifier相关类UML图</p>
</center>

如图2所示，构造`AlgebraicSimplifier`对象时需要传入一个`AlgebraicSimplifierOptions`对象，其定义了一系列的代数化简选项，如与`layout`、`dot`、`conv`、`scalar multiply reduction`、`padding`及`transpose`相关选项。`AlgebraicSimplifier`类重写了父类的`Run`方法，运行`Run`方法时会自动创建一个`AlgebraicSimplifierVisitor`对象*visitor*，之后使用*visitor*对`HloModule`中的每个`HloComputation`进行处理。每个`HloComputation`对象会使用传入的`AlgebraicSimplifierVisitor`对象从`Root HloInstruction`开始使用后序DFS遍历方式处理该computation中的每一条指令。`AlgebraicSimplifierVisitor`对象根据每条`HloInstruction`对象的`HloOpcode`值调用相应的`HandleXXX`方法处理该指令。

`AlgebraicSimplifierVisitor`类会对`Abs`、`Add`、`And`、`Bitcast`、`BitcastConvert`、`Broadcast`、`Compare`、`Concatenate`、`Constant`、`Copy`、`Convert`、`Complex`、`Real`、`Imag`、`Iota`、`Convolution`、`Divide`、`Dot`、`Gather`、`GetTupleElement`、`Log`、`Maximum`、`Minimum`、`Clamp`、`Multiply`、`Negate`、`Not`、`Or`、`Pad`、`Power`、`Remainder`、`Reshape`、`Reduce`、`ReduceWindow`、`Reverse`、`Rsqrt`、`Slice`、`Sqrt`、`DynamicSlice`、`DynamicUpdateSlice`、`Scatter`、`Select`、`Sort`、`Transpose`、`Subtract`和`Map`等46个算子进行代数化简处理。

* `HandleAbs`：当`Abs`的操作数为正时，进行`Abs(A) => A`的简化。
* `HandleAdd`: 对`Add`进行的简化操作如下：
  - `A + 0 => A`
  - `0 + A => A`
  - 将常数放在加法的右边，方便后续重分配规则的简化，即`Const + A => A + Const`
  - 对加法的操作数进行重新分配，方便后续的常量折叠，即`(A + C1) + C2 => A + (C1 + C2)`
  - 

[^1]: SPMD (Single-Program-Multiple-Data) 是最常用的分布式模式，即数据并行。